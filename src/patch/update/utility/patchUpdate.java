/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package patch.update.utility;

import java.awt.Color;
import java.awt.Component;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.util.List;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.DefaultListCellRenderer;
import javax.swing.DefaultListModel;
import javax.swing.JFileChooser;
import javax.swing.JList;
import javax.swing.JOptionPane;

/**
 *
 * @author SUBHADIP
 */
public class patchUpdate extends javax.swing.JFrame {
    
    private List<String> backupFiles;
    public List<String> getAllSourceFilePath;
    public List<String> getAllDestinationFilePath;
    public List<String> matchedNameSourceFile;
    public List<String> matchedNameDestinationFile;
    public List<String> allCsvDestinationFilePathList;
    public List<String> getAllSourceFileDuplicatePath;
    public List<String> getAllDestinationFileDuplicatePath;
    public List<String> allNewSourceFilePath;
    public String csvPrementionFilePath;
    public String logPrementionFilePath;
    public String destinationFolderPath;
    public String sourceFolderPath;
    public String backupFolderPath;
    /**
     * Creates new form patchUpdate
     */
    public patchUpdate() {
        this.setTitle("Patch Update Utility");
        //ImageIcon("P:\\NetBeansProjects\\icon.png");
       // this.setIconImage(image.getImage());
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        textField1 = new java.awt.TextField();
        textField2 = new java.awt.TextField();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jButton3 = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        jList1 = new javax.swing.JList<>();
        jScrollPane2 = new javax.swing.JScrollPane();
        jList2 = new javax.swing.JList<>();
        jScrollPane3 = new javax.swing.JScrollPane();
        jList3 = new javax.swing.JList<>();
        jLabel5 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jButton1.setBackground(new java.awt.Color(0, 153, 102));
        jButton1.setText("Browse");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jButton2.setBackground(new java.awt.Color(0, 153, 102));
        jButton2.setText("Browse");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jLabel1.setText("Select Patch Folder");

        jLabel2.setText("Select Destination Folder");

        textField2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                textField2ActionPerformed(evt);
            }
        });

        jLabel3.setText("Patch Folder contains");

        jLabel4.setText("Destination Folder contains");

        jButton3.setBackground(new java.awt.Color(0, 102, 204));
        jButton3.setText("UPDATE");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        jButton4.setBackground(new java.awt.Color(204, 0, 51));
        jButton4.setText("UNDO");
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });

        jScrollPane1.setViewportView(jList1);

        jScrollPane2.setViewportView(jList2);

        jScrollPane3.setViewportView(jList3);

        jLabel5.setText("@SuSahoo");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(288, 288, 288)
                        .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane3, javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 266, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                                .addGroup(layout.createSequentialGroup()
                                                    .addComponent(textField1, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                    .addGap(14, 14, 14))
                                                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE)
                                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)))
                                            .addComponent(jButton1)))
                                    .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(layout.createSequentialGroup()
                                        .addGap(18, 18, 18)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                                            .addComponent(jLabel4, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                            .addComponent(textField2, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 180, Short.MAX_VALUE))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(jButton2))
                                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                        .addGap(18, 18, 18)
                                        .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 262, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jButton3)
                                    .addComponent(jButton4, javax.swing.GroupLayout.PREFERRED_SIZE, 78, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(0, 4, Short.MAX_VALUE))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addGap(0, 0, Short.MAX_VALUE)
                                .addComponent(jLabel5, javax.swing.GroupLayout.PREFERRED_SIZE, 68, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addContainerGap())))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel5)
                .addGap(27, 27, 27)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGroup(layout.createSequentialGroup()
                            .addComponent(jLabel2)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(layout.createSequentialGroup()
                                    .addGap(1, 1, 1)
                                    .addComponent(textField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addComponent(textField2, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addComponent(jLabel1))
                    .addComponent(jButton1)
                    .addComponent(jButton2))
                .addGap(10, 10, 10)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(jLabel4))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 182, Short.MAX_VALUE)
                        .addComponent(jScrollPane1))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(36, 36, 36)
                        .addComponent(jButton3)
                        .addGap(37, 37, 37)
                        .addComponent(jButton4)))
                .addGap(17, 17, 17)
                .addComponent(jScrollPane3, javax.swing.GroupLayout.DEFAULT_SIZE, 109, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private static List<String> getAllFiles(File folder){
        List<String> fileList = new ArrayList<>();
        File[] files = folder.listFiles();
        if(files != null){
            for(File file:files){
                if(file.isFile()){
                    fileList.add(file.getAbsolutePath());
                }else if(file.isDirectory()){
                    fileList.addAll(getAllFiles(file));
                }
            }
        }
        return fileList;
    }
    private static List<String> removeDuplicates(List<String> list){
        List<String> newList = new ArrayList<>();
        for(String element:list){
            if(!newList.contains(element)){
                newList.add(element);
            }
        }
        return newList;
    }
    public void getSameFileNameMatch(){
        if(textField1.getText().length()>0 && textField2.getText().length()>0){
            List<String> allSourceFileList = new ArrayList<>();
            List<String> allDestinationFileList = new ArrayList<>();
            for(String sourceFilePath:getAllSourceFilePath){
                String sourceFileName = new File(sourceFilePath).getName();
                for(String destFilePath:getAllDestinationFilePath){
                    String destFileName = new File(destFilePath).getName();
                    if(sourceFileName.equals(destFileName)){
                        allSourceFileList.add(sourceFilePath);
                        allDestinationFileList.add(destFilePath);
                    }
                }
            }
            matchedNameSourceFile = removeDuplicates(allSourceFileList);
            matchedNameDestinationFile = removeDuplicates(allDestinationFileList);
            DefaultListModel<String> sourceModel = new DefaultListModel<>();
            for(String matchedSource:matchedNameSourceFile){
                sourceModel.addElement(matchedSource);
            }
            sourceModel.addElement("-----------");
            sourceModel.addElement("New Patch File Paths are ----");
            List<String> newList = new ArrayList<>();
            for(String element:getAllSourceFilePath){
                if(!matchedNameSourceFile.contains(element)){
                    newList.add(element);
                }
            }
            for(String source:newList){
                String sourceName = new File(source).getName();
                if(sourceName.equals("files.csv")){   
                }else if(sourceName.equals("filesLog.txt")){
                }else{
                    sourceModel.addElement(source);
                }
            }
            jList1.setModel(sourceModel);
            jList1.setCellRenderer(new DefaultListCellRenderer(){
                @Override
                public Component getListCellRendererComponent(JList<?> list, Object value, int index, boolean isSelected, boolean cellHasFocus){
                    Component c = super.getListCellRendererComponent(list,value,index,isSelected,cellHasFocus);
                    if(value !=null && !value.toString().isEmpty()){
                        String item = value.toString();
                        if(item.contains("New Patch Paths are")){
                            c.setForeground(Color.MAGENTA);
                        }
                        for(String matchedSource:matchedNameSourceFile){
                            String sourceFileName = new File(matchedSource).getName();
                            if(item.endsWith(sourceFileName)){
                                c.setForeground(Color.BLACK);
                                break;
                            }
                        }
                        for(String source:newList){
                            String sourceName = new File(source).getName();
                            if(item.endsWith(sourceName)){
                                c.setForeground(Color.RED);
                                break;
                            }
                        }
                        for(String file:getAllSourceFileDuplicatePath){
                            String sourceFileName = new File(file).getName();
                            if(item.endsWith(sourceFileName)){
                                c.setForeground(Color.RED);
                                break;
                            }
                        }
                    }
                    return c;
                }
            });
        }
    }
    
    private static List<String> findAllDuplicates(List<String> list){
        List<String> newList = new ArrayList<>();
        List<String> duplicateList = new ArrayList<>();
        List<String> onlyDuplicateList = new ArrayList<>();
        for(String element:list){
            newList.add(element);
        }
        for(String element:list){
            String sourceFileName = new File(element).getName();
            for(String ele:newList){
                String destFileName = new File(ele).getName();
                if(sourceFileName.equals(destFileName)){
                    if(!duplicateList.contains(ele)){
                        duplicateList.add(ele);
                    }else if(duplicateList.contains(ele)){
                        onlyDuplicateList.add(ele);
                    }
                }
            }
        }
        return onlyDuplicateList;
    }
    
    private String searchDestinationFilePath(String csvFilePath,String sourceFilePath){
        String line;
        String destinationFilePath = null;
        try(BufferedReader reader = new BufferedReader(new FileReader(csvFilePath))){
            // Skip header line
            reader.readLine();
            while((line = reader.readLine()) != null){
                String[] parts = line.split(",");
                String csvSourceFilePath = sourceFolderPath + File.separator + parts[0];
                String csvDestinationFilePath = destinationFolderPath + File.separator + parts[1];
                if(csvSourceFilePath.equals(sourceFilePath)){
                    destinationFilePath = csvDestinationFilePath;
                    break;
                }
            }
        } catch (IOException e) {
            System.err.println("An error occurred while reading the CSV file:"+e.getMessage());
        }
        return destinationFilePath;
    }
    
    private List<String> getAllDestinationFilePath(String csvFilePath){
        String line;
        List<String> destinationFileList = new ArrayList<>();
        try(BufferedReader reader = new BufferedReader(new FileReader(csvFilePath))){
            // Skip header line
            reader.readLine();
            while((line = reader.readLine()) != null){
                String[] parts = line.split(",");
                //String csvSourceFilePath = sourceFolderPath + File.separator + parts[0];
                String csvDestinationFilePath = destinationFolderPath + File.separator + parts[1];
                destinationFileList.add(csvDestinationFilePath);
            }
        } catch (IOException e) {
            System.err.println("An error occurred while reading the CSV file:"+e.getMessage());
        }
        return destinationFileList;
    }
    
    private boolean searchIfSourceFileNameMatchedInCsv(String csvFilePath, String sourceFilePath){
        String line;
        //File parent = new File(sourceFilePath).getParentFile();
        String sourceFilePathName = new File(sourceFilePath).getName();
        try(BufferedReader reader = new BufferedReader(new FileReader(csvFilePath))){
            // Skip header line
            reader.readLine();
            while((line = reader.readLine()) != null){
                String[] parts = line.split(",");
                String csvSourceFilePath = parts[0];
                //File parentCsvSource = new File(csvSourceFilePath).getParentFile();
                String csvSourceFilePathName = new File(csvSourceFilePath).getName();
                //String csvDestinationFilePath = destinationFolderPath + File.separator + parts[1];
                if(csvSourceFilePathName.equals(sourceFilePathName)){
                    return true;
                }
            }
        } catch (IOException e) {
            System.err.println("An error occurred while reading the CSV file:"+e.getMessage());
        }
        return false;
    }
    
    private String searchIfDestinationFileNameMatchedInCsv(String csvFilePath, String backupFilePath){
        String line;
        String destinationFilePath = null;
        String destinationFilePathName = new File(backupFilePath).getName();
        File parentBackupFolder =new File(backupFilePath).getParentFile();
        File parent2BackupFolder =new File(parentBackupFolder.getAbsolutePath()).getParentFile();
        try(BufferedReader reader = new BufferedReader(new FileReader(csvFilePath))){
            // Skip header line
            reader.readLine();
            while((line = reader.readLine()) != null){
                String[] parts = line.split(",");
                String csvDestinationFilePath = parts[1];
                File parent = new File(csvDestinationFilePath).getParentFile();
                File parent2 = new File(parent.getAbsolutePath()).getParentFile();
                String csvDestinationFilePathName = parent.getName() + "_" + new File(csvDestinationFilePath).getName();
                //String csvDestinationFilePath = destinationFolderPath + File.separator + parts[1];
                if(csvDestinationFilePathName.equals(destinationFilePathName)){
                    destinationFilePath = destinationFolderPath + File.separator + csvDestinationFilePath;
                    return destinationFilePath;
                }
            }
        } catch (IOException e) {
            System.err.println("An error occurred while reading the CSV file:"+e.getMessage());
        }
        return destinationFilePath;
    }
    
    private boolean searchIfDestinationFilePath(String csvFilePath, String destinationFilePath){
        String line;
         try(BufferedReader reader = new BufferedReader(new FileReader(csvFilePath))){
            // Skip header line
            reader.readLine();
            while((line = reader.readLine()) != null){
                String[] parts = line.split(",");
                //String csvSourceFilePath = parts[0];
                String csvDestinationFilePath = destinationFolderPath + File.separator + parts[1];
                if(csvDestinationFilePath.equals(destinationFilePath)){
                    return true;
                }
            }
        } catch (IOException e) {
            System.err.println("An error occurred while reading the CSV file:"+e.getMessage());
        }
         return false;
    }
    
    private String ifDestinationReturnSource(String csvFilePath, String destinationFilePath){
        String line;
        String sourceFilePath = null;
         try(BufferedReader reader = new BufferedReader(new FileReader(csvFilePath))){
            // Skip header line
            reader.readLine();
            while((line = reader.readLine()) != null){
                String[] parts = line.split(",");
                String csvSourceFilePath = sourceFolderPath + File.separator + parts[0];
                String csvDestinationFilePath = destinationFolderPath + File.separator + parts[1];
                if(csvDestinationFilePath.equals(destinationFilePath)){
                    sourceFilePath = csvSourceFilePath;
                    return sourceFilePath;
                }
            }
        } catch (IOException e) {
            System.err.println("An error occurred while reading the CSV file:"+e.getMessage());
        }
         return sourceFilePath;
    }
    
    public void writeToFile(String logStatus){
        SimpleDateFormat ft2 = new SimpleDateFormat("dd-MM-YYYY HH:mm:ss");
        String dateTime = ft2.format(new Date());
        try{
            PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(logPrementionFilePath,true)));
            out.println(dateTime + logStatus);
            out.close();
        } catch (IOException e) {
            System.err.println("An error occurred while writing to the Log file: "+e.getMessage());
        }
    }
    
    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // TODO add your handling code here:
        JFileChooser chooser1 = new javax.swing.JFileChooser("C:\\");
        chooser1.setFileSelectionMode(javax.swing.JFileChooser.DIRECTORIES_ONLY);
        chooser1.showOpenDialog(null);
        File f1 = chooser1.getSelectedFile();
        if(f1 != null){
            String filename1 = f1.getAbsolutePath();
            textField1.setText(filename1);
            sourceFolderPath = textField1.getText();
            String csvFilePath = sourceFolderPath + File.separator + "files.csv";
            File csvFile = new File(csvFilePath);
            if(!csvFile.exists()){
                JOptionPane.showMessageDialog(patchUpdate.this, "CSV File can not be Found !");
                System.exit(0);
            }
            String filesLogPath = sourceFolderPath + File.separator + "filesLog.txt";
            File filesLogFile = new File(filesLogPath);
            // Create backup folder if it doesnot 
            try{
                if(!filesLogFile.exists()){
                    boolean fileCreated = filesLogFile.createNewFile();
                    if(!fileCreated){
                         JOptionPane.showMessageDialog(patchUpdate.this, "Failed to create Log File : " +filesLogPath);
                    }
                }
            }catch(IOException e){
                System.out.println("An error occurred: "+ e.getMessage());
            }
            getAllSourceFilePath = getAllFiles(f1);
            getAllSourceFileDuplicatePath = findAllDuplicates(getAllSourceFilePath);
            DefaultListModel <String> sourceModel = new DefaultListModel<>();
            for (String file : getAllSourceFilePath) {
                String fileName = new File(file).getName();
               // if(!fileName.equals("files.csv"){
               //     sourceModel.addElement(file);
               // }
                if(fileName.equals("files.csv")){
                    csvPrementionFilePath = file;
                }else if(fileName.equals("filesLog.txt")){
                    logPrementionFilePath = file;
                }else{
                    sourceModel.addElement(file);
                }
            }
            jList1.setModel(sourceModel);
            
            jList1.setCellRenderer(new DefaultListCellRenderer(){
                @Override
                public Component getListCellRendererComponent(JList<?> list, Object value, int index, boolean isSelected, boolean cellHasFocus){
                    Component c = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
                    if(value != null && !value.toString().isEmpty()){
                        String item = value.toString();
                        for(String file:getAllSourceFileDuplicatePath){
                            String sourceFileName = new File(file).getName();
                            if(item.endsWith(sourceFileName)){
                                c.setForeground(Color.RED);
                                break;
                            }else{
                                c.setForeground(Color.BLACK);
                            }
                        }
                    }
                    return c;
                }
            });
//            for(String file:getAllSourceFilePath){
//                String fileName = new File(file).getName();
//                if(!fileName.equals("files.csv")){
//                    list1.add(file);
//                }else if(fileName.equals("files.csv")){
//                    csvPrementionFilePath = file;
//                }
//            }
//            sourceFolderPath = textField1.getText();
//            getSameFileNameMatch();
        }
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        // TODO add your handling code here:
        JFileChooser chooser2 = new javax.swing.JFileChooser("C:\\");
        chooser2.setFileSelectionMode(javax.swing.JFileChooser.DIRECTORIES_ONLY);
        chooser2.showOpenDialog(null);
        File f2 = chooser2.getSelectedFile();
        if(f2 != null){
            String filename2 = f2.getAbsolutePath();
            textField2.setText(filename2);
            // list2.removeAll();
            getAllDestinationFilePath = getAllFiles(f2);
            getSameFileNameMatch();
            getAllDestinationFileDuplicatePath = findAllDuplicates(matchedNameDestinationFile);
            DefaultListModel<String> destinationModel = new DefaultListModel<>();
            for(String file:matchedNameDestinationFile){
                destinationModel.addElement(file);
            }
            jList2.setModel(destinationModel);
            destinationFolderPath = textField2.getText();
            jList2.setCellRenderer(new DefaultListCellRenderer(){
                @Override
                public Component getListCellRendererComponent(JList<?> list, Object value, int index, boolean isSelected, boolean cellHasFocus){
                    Component c = super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
                    if(value != null && !value.toString().isEmpty()){
                        String item = value.toString();
                        for(String file:getAllDestinationFileDuplicatePath){
                            String sourceFileName = new File(file).getName();
                            if(item.endsWith(sourceFileName)){
                                c.setForeground(Color.RED);
                                break;
                            }else{
                                c.setForeground(Color.BLACK);
                            }
                        }
                    }
                    return c;
                }
            });
            
//            for(String fileDestination:matchedNameDestinationFile){
//                list2.add(fileDestination);
//            }
        }
    }//GEN-LAST:event_jButton2ActionPerformed

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        // TODO add your handling code here:
        SimpleDateFormat ft = new SimpleDateFormat("dd-MM-YYYY");
        String date = ft.format(new Date());
        if(textField1.getText().length()>0){
//            sourcePath = textField1.getText();
//            sourceFiles = getAllFiles(new File(sourcePath));
//            for(String file:sourceFiles){
//                String fileName = new File(file).getName();
//                if(fileName.equals("files.csv")){
//                    csvPrementionFilePath = file;
//                }
//            }
        }else{
            JOptionPane.showMessageDialog(patchUpdate.this, "Please First Select Source Folder !");
        }
        
        if(textField2.getText().length()>0){
//            destPath = textField2.getText();
//            destinationFiles = getAllFiles(new File(destPath));
        }else{
            JOptionPane.showMessageDialog(patchUpdate.this, "Please First Select Destination Folder !");
        }
        
        if(textField1.getText().length()>0 && textField2.getText().length()>0){
            DefaultListModel<String> statusModel = new DefaultListModel<>();
            // Create Backup Foldel outside destination Folder
            backupFolderPath = sourceFolderPath.substring(0,sourceFolderPath.lastIndexOf(File.separator)) + File.separator + "PatchUpdateBackup" + "_"+ date;
            File backupFolder = new File(backupFolderPath);
            // Create backup folder if it doesnot exists
            if(!backupFolder.exists()){
                boolean created = backupFolder.mkdirs();
                if(!created){
                    statusModel.addElement("------------------------");
                    statusModel.addElement("Backup Folder Can Not be Created :: "+backupFolderPath);
                    statusModel.addElement("------------------------");
                    writeToFile("---------------------");
                    writeToFile("Backup Folder Can Not be Created :: "+backupFolderPath);
                    writeToFile("---------------------");
                    JOptionPane.showMessageDialog(patchUpdate.this, "Backup Folder Can Not be Created : "+backupFolderPath);
                    return;
                }else{
                    statusModel.addElement("------------------------");
                    statusModel.addElement("Backup Folder Created at :: "+backupFolderPath);
                    statusModel.addElement("------------------------");
                    writeToFile("---------------------");
                    writeToFile("Backup Folder Created at :: "+backupFolderPath);
                    writeToFile("---------------------");
                }
            }else if(backupFolder.exists()){
                statusModel.addElement("------------------------");
                statusModel.addElement("Backup Folder Already Exists at :: "+backupFolderPath);
                statusModel.addElement("------------------------");
                writeToFile("---------------------");
                writeToFile("Backup Folder Already Exists at :: "+backupFolderPath);
                writeToFile("---------------------");
            }
            allCsvDestinationFilePathList = getAllDestinationFilePath(csvPrementionFilePath);
            for(String csvDestPath:allCsvDestinationFilePathList){
                File parent = new File(csvDestPath).getParentFile();
                if(!parent.exists()){
                    boolean folderCreated = parent.mkdirs();
                    if(!folderCreated){
                        JOptionPane.showMessageDialog(patchUpdate.this, "Failed to create the new folder in Destination !" + parent.getAbsolutePath());
                        statusModel.addElement("------------------------");
                        statusModel.addElement("Failed to create the new folder Destination at :: " + parent.getAbsolutePath());
                        statusModel.addElement("------------------------");
                        writeToFile("---------------------");
                        writeToFile("Failed to create the new folder Destination at :: " + parent.getAbsolutePath());
                        writeToFile("---------------------");
                    }else{
                        statusModel.addElement("------------------------");
                        statusModel.addElement("Folder created successfully at :: " + parent.getAbsolutePath());
                        statusModel.addElement("------------------------");
                        writeToFile("---------------------");
                        writeToFile("Folder created successfully at :: " + parent.getAbsolutePath());
                        writeToFile("---------------------");
                    }
                }
                File destFilePath = new File(csvDestPath);
                try{
                    if(!destFilePath.exists()){
                        boolean fileCreated = destFilePath.createNewFile();
                        matchedNameDestinationFile.add(csvDestPath);
                        String sourceFilePath = ifDestinationReturnSource(csvPrementionFilePath,csvDestPath);
                        if(sourceFilePath != null){
                            matchedNameSourceFile.add(sourceFilePath);
                        }
                        if(!fileCreated){
                            JOptionPane.showMessageDialog(patchUpdate.this, "Failed to create the new File Destination at : " + destFilePath.getAbsolutePath());
                            statusModel.addElement("------------------------");
                            statusModel.addElement("Failed to create the new File Destination at :: " + destFilePath.getAbsolutePath());
                            statusModel.addElement("------------------------");
                            writeToFile("---------------------");
                            writeToFile("Failed to create the new File Destination at :: " + destFilePath.getAbsolutePath());
                            writeToFile("---------------------");
                        }else{
                            statusModel.addElement("------------------------");
                            statusModel.addElement("File created Successfully at :: " + destFilePath.getAbsolutePath());
                            statusModel.addElement("------------------------");
                            writeToFile("---------------------");
                            writeToFile("File created Successfully at :: " + destFilePath.getAbsolutePath());
                            writeToFile("---------------------");
                        }
                    }
                }catch(IOException e){
                    System.out.println("An error occurred: "+ e.getMessage());
                }        
            }
            statusModel.addElement("Replace & Backup Files Status -----");
            
            List<String> filesCompletedSrc = new ArrayList<>();
            List<String> filesCompletedDest = new ArrayList<>();
            
            for(String sourceFilePath:matchedNameSourceFile){
                //String sourceFileName = new File(sourceFilePath).getName();
                String destinationFilePath = searchDestinationFilePath(csvPrementionFilePath, sourceFilePath);
                // 742
                if(destinationFilePath != null){
                    String destinationFileName = new File(destinationFilePath).getName();
                    File parent = new File(destinationFilePath).getParentFile();
                    File parent2 = new File(parent.getAbsolutePath()).getParentFile();
                    String backupFileParentFolderPath = backupFolderPath + File.separator + parent2.getName() + File.separator + parent.getName();
                    File backupFileParentFolder = new File(backupFileParentFolderPath);
                    if(!backupFileParentFolder.exists()){
                        boolean created = backupFileParentFolder.mkdirs();
                        if(!created){
                            JOptionPane.showMessageDialog(patchUpdate.this, "Backup File Parent Folder can not be created at : " + backupFileParentFolder);
                            statusModel.addElement("------------------------");
                            statusModel.addElement("Backup File Parent Folder can not be created at :: " + backupFileParentFolder);
                            statusModel.addElement("------------------------");
                            writeToFile("---------------------");
                            writeToFile("Backup File Parent Folder can not be created at : " + backupFileParentFolder);
                            writeToFile("---------------------");
                            return;
                        }
                    }
                    //String backupFilePath = backupFolderPath + File.separator + date + destinationFileName;
                    String backupFilePath = backupFolderPath+File.separator+parent2.getName()+File.separator+parent.getName()+File.separator+destinationFileName;
                    Path sourcePath = Paths.get(sourceFilePath);
                    Path destPath = Paths.get(destinationFilePath);
                    Path backupPath = Paths.get(backupFilePath);
                    try{
                        if(!Files.exists(backupPath)){
                            Files.copy(destPath, backupPath, StandardCopyOption.COPY_ATTRIBUTES);
                            //list3.add("Backup Created for : "+destPath);
                            statusModel.addElement("Backup Created for : "+destPath);
                            writeToFile("Backup Created for : "+destPath);
                            Files.copy(sourcePath, destPath, StandardCopyOption.REPLACE_EXISTING);
                            //list3.add("File Replaced at : "+destPath);
                            statusModel.addElement("File Replaced at : "+destPath);
                            writeToFile("File Replaced at : "+destPath);
                            filesCompletedSrc.add(sourcePath.toString());
                            filesCompletedDest.add(destPath.toString());
                        }else if(Files.exists(backupPath)){
                            //list3.add("Backup Not Created at : "+destPath);
                            statusModel.addElement("Backup Not Created at : "+destPath);
                            writeToFile("Backup Not Created at : "+destPath);
                            Files.copy(sourcePath, destPath, StandardCopyOption.REPLACE_EXISTING);
                            //list3.add("File Replaced at : "+destPath);
                            statusModel.addElement("File Replaced at : "+destPath);
                            writeToFile("File Replaced at : "+destPath);
                            filesCompletedSrc.add(sourcePath.toString());
                            filesCompletedDest.add(destPath.toString());
                        }
                    }catch (IOException ex) {
                       Logger.getLogger(patchUpdate.class.getName()).log(Level.SEVERE, null, ex);
                   } 
                }
            }
            //820
            matchedNameSourceFile.removeAll(filesCompletedSrc);
            matchedNameDestinationFile.removeAll(filesCompletedDest);
            Set<String> problems = new HashSet<String>();
            for(String sourceFilePath:matchedNameSourceFile){
                String sourceFileName = new File(sourceFilePath).getName();
                boolean sourceFileCsv = searchIfSourceFileNameMatchedInCsv(csvPrementionFilePath,sourceFilePath);
                if(sourceFileCsv == false){
                    for(String destFilePath:matchedNameDestinationFile){
                        String destFileName = new File(destFilePath).getName();
                        boolean searchDestination = searchIfDestinationFilePath(csvPrementionFilePath,destFilePath);
                        if(searchDestination == false && getAllDestinationFileDuplicatePath.contains(destFilePath)){
                            problems.add(sourceFilePath);
                            continue;
                        }
                        if(sourceFileName.equals(destFileName)){
                            File parent = new File(destFilePath).getParentFile();
                            File parent2 = new File(parent.getAbsolutePath()).getParentFile();
                            String backupFileParentFolderPath = backupFolderPath + File.separator +parent2.getName()+File.separator+parent.getName();
                            File backupFileParentFolder = new File(backupFileParentFolderPath);
                            if(!backupFileParentFolder.exists()){
                                boolean created = backupFileParentFolder.mkdirs();
                                if(!created){
                                    JOptionPane.showMessageDialog(patchUpdate.this, "Backup File Parent Folder can not be Created !");
                                    return;
                                }
                            }
                            String backupFilePath = backupFolderPath + File.separator +parent2.getName() +File.separator +parent.getName()+File.separator+destFileName;
                            //String backupFilePath = backupFolderPath + File.separator +parent.getName() +"_" +destFileName;
                            Path sourcePath = Paths.get(sourceFilePath);
                            Path destPath = Paths.get(destFilePath);
                            Path backupPath = Paths.get(backupFilePath);
                            try{
                                //894
                                if(!Files.exists(backupPath)){
                                    Files.copy(destPath, backupPath, StandardCopyOption.COPY_ATTRIBUTES);
                                    //list3.add("Backup Created for : "+destPath);
                                    statusModel.addElement("Backup Created for : "+destPath);
                                    writeToFile("Backup Created for : "+destPath);
                                    Files.copy(sourcePath, destPath, StandardCopyOption.REPLACE_EXISTING);
                                    //list3.add("File Replaced at : "+destPath);
                                    statusModel.addElement("File Replaced at : "+destPath);
                                    writeToFile("File Replaced at : "+destPath);
                                    filesCompletedSrc.add(sourcePath.toString());
                                    filesCompletedDest.add(destPath.toString());
                                }else if(Files.exists(backupPath)){
                                    //list3.add("Backup Not Created at : "+destPath);
                                    statusModel.addElement("Backup Not Created at : "+destPath);
                                    writeToFile("Backup Not Created at : "+destPath);
                                    Files.copy(sourcePath, destPath, StandardCopyOption.REPLACE_EXISTING);
                                    //list3.add("File Replaced at : "+destPath);
                                    statusModel.addElement("File Replaced at : "+destPath);
                                    writeToFile("File Replaced at : "+destPath);
                                    filesCompletedSrc.add(sourcePath.toString());
                                    filesCompletedDest.add(destPath.toString());
                                }
                            }catch (IOException ex) {
                               Logger.getLogger(patchUpdate.class.getName()).log(Level.SEVERE, null, ex);
                            }
                        }
                    }
                }
            }
            
           problems.removeAll(filesCompletedSrc);
           for(String prob:problems){
               String errMsg = "Failure in Updating the "+prob+"as it is not resolved through CSV";
               statusModel.addElement(errMsg);
               writeToFile(errMsg);
           }
           File backupFolder2 = new File(backupFolderPath);
           if(backupFolder.exists()){
               backupFiles = getAllFiles(backupFolder2);
           }
           //statusModel.addElement("Empty Files are ");
           for(String backupFilePath:backupFiles){
               if(new File(backupFilePath).length()==0){
                   //statusModel.addElement(backupFilePath);
                   try {
                       Files.delete(Paths.get(backupFilePath));
                   } catch (IOException ex) {
                       Logger.getLogger(patchUpdate.class.getName()).log(Level.SEVERE, null, ex);
                   }
               }
           }
           statusModel.addElement("Patch Uploaded Successfully.");
           jList3.setModel(statusModel);
           jList3.setCellRenderer(new DefaultListCellRenderer(){
                @Override
                public Component getListCellRendererComponent(JList<?> list, Object value, int index, boolean isSelected, boolean cellHasFocus){
                    Component c = super.getListCellRendererComponent(list,value,index,isSelected,cellHasFocus);
                    if(value !=null && !value.toString().isEmpty()){
                        String item = value.toString();
                        if(item.contains("Not")){
                            c.setForeground(Color.RED);
                        }else if(item.contains("Failure")){
                            c.setForeground(Color.RED);
                        }else if(item.contains("Backup Folder Already Exists at")){
                            c.setForeground(Color.RED);
                        }else if(item.contains("Replace & Backup Files Status")){
                            c.setForeground(Color.BLACK);
                        }else if(item.contains("Backup Folder Created at")){
                            c.setForeground(Color.MAGENTA);
                        }else if(item.startsWith("---")){
                            c.setForeground(Color.MAGENTA);
                        }else{
                            c.setForeground(Color.BLUE);
                        }
                    }
                    return c;
                }
            });
            JOptionPane.showMessageDialog(patchUpdate.this,"Patch Uploaded Successfully.");
        }
        
    }//GEN-LAST:event_jButton3ActionPerformed

    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton4ActionPerformed
        // TODO add your handling code here:
        SimpleDateFormat ft=new SimpleDateFormat("dd-MM-YYYY");
        String date = ft.format(new Date());
        if(textField1.getText().length()>0){
            
        }else{
            JOptionPane.showMessageDialog(patchUpdate.this,"Please First Select Patch Folder.");
        }
        if(textField2.getText().length()>0){
            //destPath = textField2.getText();
            //destinationFiles = getAllFiles(new File(destPath));
            
            backupFolderPath = sourceFolderPath.substring(0,sourceFolderPath.lastIndexOf(File.separator))+ File.separator + "PatchUpdateBackup"+"_"+ date;
            File backupFolder = new File(backupFolderPath);
            if(backupFolder.exists()){
                backupFiles = getAllFiles(backupFolder);
            }else{
                JOptionPane.showMessageDialog(patchUpdate.this,"Patch Update Backup Folder can not be Found !!");
            }  
        }else{
            JOptionPane.showMessageDialog(patchUpdate.this,"Please First Select Destination Folder.");
        }
        
        if(textField1.getText().length()>0 && textField2.getText().length()>0){
            File backupFolder = new File(backupFolderPath);
            if(backupFolder.exists()){
                DefaultListModel<String> statusModel = new DefaultListModel<>();
                statusModel.addElement("------------------------");
                statusModel.addElement("Replace UNDO Files are ----");
                statusModel.addElement("------------------------");
                writeToFile("---------------------");
                writeToFile("Replace UNDO Files are ----");
                writeToFile("---------------------");
                
//                for(String backupFilePath:backupFiles){
//                    String backupFileName = new File(backupFilePath).getName();
//                    String backupMatchedFile = searchIfDestinationFileNameMatchedInCsv(csvPrementionFilePath,backupFilePath);
//                    if(backupMatchedFile != null){
//                        Path destPath = Paths.get(backupMatchedFile);
//                        if(new File(backupFilePath).exists()){
//                            Path backupPath = Paths.get(backupFilePath);
//                            try {
//                                Files.copy(backupPath, destPath, StandardCopyOption.REPLACE_EXISTING);
//                                //list3.add("Replace UNDO at : "+destPath);
//                                statusModel.addElement("Replace UNDO at : "+destPath);
//                            } catch (IOException ex) {
//                                Logger.getLogger(patchUpdate.class.getName()).log(Level.SEVERE, null, ex);
//                            }
//                        }
//                    }else{
//                        for(String destFilePath:matchedNameDestinationFile){
//                            String destFileName = new File(destFilePath).getName();
//                            File parent = new File(destFilePath).getParentFile();
//                            if(backupFileName.equals(parent.getName()+"_"+destFileName)){
//                                Path destPath = Paths.get(destFilePath);
//                                if(new File(backupFilePath).exists()){
//                                    Path backupPath = Paths.get(backupFilePath);
//                                    try {
//                                        Files.copy(backupPath, destPath, StandardCopyOption.REPLACE_EXISTING);
//                                        //list3.add("Replace UNDO at : "+destPath);
//                                        statusModel.addElement("Replace UNDO at : "+destPath);
//                                    } catch (IOException ex) {
//                                        Logger.getLogger(patchUpdate.class.getName()).log(Level.SEVERE, null, ex);
//                                    }
//                                }
//                            }
//                        }
//                    }
//                
//                }
                
                for(String backupFilePath:backupFiles){
                    String backupFileName = new File(backupFilePath).getName();
                    File parentBackupFolder = new File(backupFilePath).getParentFile();
                    File parent2BackupFolder = new File(parentBackupFolder.getAbsolutePath()).getParentFile();
                    String parentBackupFolderName = parentBackupFolder.getName();
                    String parent2BackupFolderName = parent2BackupFolder.getName();
                    
                    for(String destFilePath:matchedNameDestinationFile){
                        //1119
                        String destFileName = new File(destFilePath).getName();
                        File parentDestinationFolder = new File(destFilePath).getParentFile();
                        File parent2DestinationFolder = new File(parentDestinationFolder.getAbsolutePath()).getParentFile();
                        String parentDestinationFolderName = parentDestinationFolder.getName();
                        String parent2DestinationFolderName = parent2DestinationFolder.getName();
                        if((backupFileName.equals(destFileName)) && (parentBackupFolderName.equals(parentDestinationFolderName)) && (parent2BackupFolderName.equals(parent2DestinationFolderName))){
                            Path destPath = Paths.get(destFilePath);
                            Path backupPath = Paths.get(backupFilePath);
                            try {
                                Files.copy(backupPath, destPath, StandardCopyOption.REPLACE_EXISTING);
                                statusModel.addElement("Replace UNDO at :: "+destPath);
                                writeToFile("Replace UNDO at :: "+destPath);
                            } catch (IOException ex) {
                                Logger.getLogger(patchUpdate.class.getName()).log(Level.SEVERE, null, ex);
                                statusModel.addElement("Replace UNDO Not Working at :: "+destPath);
                                writeToFile("Replace UNDO Not Working at :: "+destPath);
                            }   
                        }   
                    }      
                }
//                statusModel.addElement("Empty Files are :: ");
//                for(String destFilePath:matchedNameDestinationFile){
//                    if(new File(destFilePath).length()==0){
//                        statusModel.addElement(destFilePath);
//                        Files.delete(destFilePath);
//                    }
//                }

                statusModel.addElement("Patch Upload Undo Successfull !");
                jList3.setModel(statusModel);
                jList3.setCellRenderer(new DefaultListCellRenderer(){
                    @Override
                    public Component getListCellRendererComponent(JList<?> list, Object value, int index, boolean isSelected, boolean cellHasFocus){
                        Component c = super.getListCellRendererComponent(list,value,index,isSelected,cellHasFocus);
                        if(value !=null && !value.toString().isEmpty()){
                            String item = value.toString();
                            if(item.contains("Not")){
                                c.setForeground(Color.RED);
                            }else if(item.contains("Replace UNDO Files are")){
                                c.setForeground(Color.MAGENTA);
                            }else if(item.startsWith("---")){
                                c.setForeground(Color.MAGENTA);
                            }else{
                                c.setForeground(Color.BLUE);
                            }
                        }
                        return c;
                    }
                });
                JOptionPane.showMessageDialog(patchUpdate.this,"Patch Upload Undo Successfull !");
            }
        }     
    }//GEN-LAST:event_jButton4ActionPerformed

    private void textField2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_textField2ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_textField2ActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(patchUpdate.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(patchUpdate.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(patchUpdate.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(patchUpdate.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new patchUpdate().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton4;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JList<String> jList1;
    private javax.swing.JList<String> jList2;
    private javax.swing.JList<String> jList3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private java.awt.TextField textField1;
    private java.awt.TextField textField2;
    // End of variables declaration//GEN-END:variables

    private void ImageIcon(String pNetBeansProjectsiconpng) {
        throw new UnsupportedOperationException("Not supported yet."); // Generated from nbfs://nbhost/SystemFileSystem/Templates/Classes/Code/GeneratedMethodBody
    }
}
